"""Implements the print stat line doubling"""
import re
from enum import Enum
from typing import List

from ...const import InputEventName
from ..event_processor import ProcessorEvent, StateWatcher


class PrintStatDoubler(StateWatcher):
    """
    The print stats are coming automatically, as we read a line at a time, we
    lose the info of which one is valid and so cannot decide
    on which one to use.
    With this, we can handle both lines at the same time without heavily
    modifying the underlying serial communication layers
    """

    class OutputEvent(Enum):
        """Events that are generated by the state watcher"""
        PRINT_INFO = "PRINT_INFO"

    def __init__(self):
        super().__init__()

        self.event_handlers = {
            InputEventName.PRINT_INFO_RECEIVED: self.print_info_received,
            InputEventName.OK_RECEIVED: self.ok_received,
        }

        self.matches: List[re.Match] = []

    def _after_register(self):
        """Called after the event is registered with the processor"""
        self._stop_watching(InputEventName.OK_RECEIVED)

    def ok_received(self, sender, match):
        """Resets the accumulated stat lines from the list"""
        assert sender is not None
        assert match is not None
        self._reset()

    def print_info_received(self, sender, match):
        """A print stat line was matched, add it to the list. If we have both,
        send them along to the handler"""
        assert sender is not None
        self.matches.append(match)

        if len(self.matches) < 2:
            self._watch(InputEventName.OK_RECEIVED)
            return None

        matches = self.matches
        self._reset()
        return ProcessorEvent(self.OutputEvent.PRINT_INFO, matches)

    def _reset(self):
        """Reset the state of the watcher"""
        self.matches.clear()
        self._stop_watching(InputEventName.OK_RECEIVED)
